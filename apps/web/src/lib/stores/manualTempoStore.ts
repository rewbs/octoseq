import { create } from "zustand";
import { devtools } from "zustand/middleware";
import type { TempoHypothesis, TempoHypothesisEvidence } from "@octoseq/mir";

/**
 * Beat mark for two-beat tempo marking.
 */
export type BeatMark = {
    timeSec: number;
};

/**
 * Source type for tempo hypotheses.
 * - algorithmic: Generated by MIR analysis (B2)
 * - manual: Created by user via direct BPM entry
 * - edited: Duplicated from another hypothesis and modified
 */
export type TempoHypothesisSource = "algorithmic" | "manual" | "edited";

/**
 * Extended tempo hypothesis with source tracking.
 * This type wraps the base TempoHypothesis with additional metadata
 * for manual tempo entry and editing.
 */
export type ExtendedTempoHypothesis = TempoHypothesis & {
    /** How this hypothesis was created. */
    source: TempoHypothesisSource;
    /** Original hypothesis ID if this was duplicated/edited. */
    sourceHypothesisId?: string;
    /** Timestamp when this hypothesis was created. */
    createdAt: string;
};

/**
 * Create default evidence for manual hypotheses.
 * Manual hypotheses have no algorithmic evidence, but we need
 * the structure for compatibility with the existing UI.
 */
function createManualEvidence(): TempoHypothesisEvidence {
    return {
        supportingIntervalCount: 0,
        weightedSupport: 0,
        peakHeight: 0,
        binRange: [0, 0],
    };
}

/**
 * Generate a deterministic family ID for a BPM value.
 * Uses the same logic as the algorithmic hypothesis generator.
 */
function generateFamilyId(bpm: number): string {
    return `fam-${Math.round(bpm)}`;
}

interface ManualTempoState {
    /** Manual and edited tempo hypotheses. */
    hypotheses: ExtendedTempoHypothesis[];
    /** Counter for generating unique IDs. */
    nextId: number;
    /** Tap tempo history for tap-to-nudge feature. */
    tapHistory: number[];
    /** Last tap timestamp for tap-to-nudge. */
    lastTapTime: number | null;
    // --- Beat Marking State ---
    /** Whether beat marking mode is active. */
    beatMarkingActive: boolean;
    /** First beat mark (null if not yet placed). */
    beatMark1: BeatMark | null;
    /** Second beat mark (null if not yet placed). */
    beatMark2: BeatMark | null;
}

interface ManualTempoActions {
    /**
     * Create a new manual tempo hypothesis from a BPM value.
     * @param bpm - The BPM value (will be rounded to 0.1 precision)
     * @returns The created hypothesis
     */
    createManualHypothesis: (bpm: number) => ExtendedTempoHypothesis;

    /**
     * Duplicate an existing hypothesis for editing.
     * Creates a new "edited" hypothesis with the same BPM.
     * @param source - The hypothesis to duplicate
     * @returns The new edited hypothesis
     */
    duplicateHypothesis: (source: TempoHypothesis) => ExtendedTempoHypothesis;

    /**
     * Update the BPM of an existing manual/edited hypothesis.
     * This creates a new hypothesis to preserve auditability.
     * @param hypothesisId - ID of the hypothesis to update
     * @param newBpm - New BPM value
     * @returns The updated hypothesis, or null if not found
     */
    updateHypothesisBpm: (hypothesisId: string, newBpm: number) => ExtendedTempoHypothesis | null;

    /**
     * Delete a manual/edited hypothesis.
     * @param hypothesisId - ID of the hypothesis to delete
     */
    deleteHypothesis: (hypothesisId: string) => void;

    /**
     * Record a tap for tap-to-nudge feature.
     * Returns the implied BPM adjustment, or null if not enough taps.
     * @param currentBpm - Current BPM to nudge from
     * @returns Suggested BPM adjustment, or null
     */
    recordTap: (currentBpm: number) => number | null;

    /**
     * Clear tap history.
     */
    clearTapHistory: () => void;

    /**
     * Clear all manual/edited hypotheses.
     */
    clear: () => void;

    // --- Beat Marking Actions ---

    /**
     * Start beat marking mode.
     */
    startBeatMarking: () => void;

    /**
     * Stop beat marking mode and clear marks.
     */
    stopBeatMarking: () => void;

    /**
     * Place a beat mark. If beat1 is null, places beat1. Otherwise places beat2.
     */
    placeBeatMark: (timeSec: number) => void;

    /**
     * Update a beat mark position (for dragging).
     */
    updateBeatMark: (beatIndex: 1 | 2, timeSec: number) => void;

    /**
     * Reset beat marks but stay in marking mode.
     */
    resetBeatMarks: () => void;

    /**
     * Calculate BPM from current beat marks.
     * Returns null if not enough marks or invalid BPM.
     */
    getMarkedBpm: () => { bpm: number; phaseOffset: number } | null;
}

export type ManualTempoStore = ManualTempoState & ManualTempoActions;

const TAP_TIMEOUT_MS = 2000; // Reset tap history after 2 seconds of inactivity
const MIN_TAPS_FOR_NUDGE = 3; // Need at least 3 taps to estimate tempo
const MAX_TAP_HISTORY = 8; // Keep last 8 taps

const initialState: ManualTempoState = {
    hypotheses: [],
    nextId: 0,
    tapHistory: [],
    lastTapTime: null,
    beatMarkingActive: false,
    beatMark1: null,
    beatMark2: null,
};

export const useManualTempoStore = create<ManualTempoStore>()(
    devtools(
        (set, get) => ({
            ...initialState,

            createManualHypothesis: (bpm: number) => {
                const state = get();
                const roundedBpm = Math.round(bpm * 10) / 10;
                const id = `manual-${state.nextId}`;

                const hypothesis: ExtendedTempoHypothesis = {
                    id,
                    bpm: roundedBpm,
                    confidence: 1.0, // Manual entries get full confidence
                    evidence: createManualEvidence(),
                    familyId: generateFamilyId(roundedBpm),
                    harmonicRatio: 1.0,
                    source: "manual",
                    createdAt: new Date().toISOString(),
                };

                set(
                    (state) => ({
                        hypotheses: [...state.hypotheses, hypothesis],
                        nextId: state.nextId + 1,
                    }),
                    false,
                    "createManualHypothesis"
                );

                return hypothesis;
            },

            duplicateHypothesis: (source: TempoHypothesis) => {
                const state = get();
                const id = `edited-${state.nextId}`;

                const hypothesis: ExtendedTempoHypothesis = {
                    id,
                    bpm: source.bpm,
                    confidence: 1.0, // Edited entries get full confidence
                    evidence: { ...source.evidence }, // Copy evidence for reference
                    familyId: source.familyId,
                    harmonicRatio: source.harmonicRatio,
                    source: "edited",
                    sourceHypothesisId: source.id,
                    createdAt: new Date().toISOString(),
                };

                set(
                    (state) => ({
                        hypotheses: [...state.hypotheses, hypothesis],
                        nextId: state.nextId + 1,
                    }),
                    false,
                    "duplicateHypothesis"
                );

                return hypothesis;
            },

            updateHypothesisBpm: (hypothesisId: string, newBpm: number) => {
                const state = get();
                const existing = state.hypotheses.find((h) => h.id === hypothesisId);

                if (!existing) {
                    return null;
                }

                const roundedBpm = Math.round(newBpm * 10) / 10;

                // Update in place for manual/edited hypotheses
                const updated: ExtendedTempoHypothesis = {
                    ...existing,
                    bpm: roundedBpm,
                    familyId: generateFamilyId(roundedBpm),
                    // Reset harmonic ratio since BPM changed
                    harmonicRatio: 1.0,
                };

                set(
                    (state) => ({
                        hypotheses: state.hypotheses.map((h) =>
                            h.id === hypothesisId ? updated : h
                        ),
                    }),
                    false,
                    "updateHypothesisBpm"
                );

                return updated;
            },

            deleteHypothesis: (hypothesisId: string) => {
                set(
                    (state) => ({
                        hypotheses: state.hypotheses.filter((h) => h.id !== hypothesisId),
                    }),
                    false,
                    "deleteHypothesis"
                );
            },

            recordTap: (currentBpm: number) => {
                const now = Date.now();
                const state = get();

                // Reset history if too much time has passed
                let newHistory = state.tapHistory;
                if (state.lastTapTime && now - state.lastTapTime > TAP_TIMEOUT_MS) {
                    newHistory = [];
                }

                // Add new tap
                newHistory = [...newHistory, now].slice(-MAX_TAP_HISTORY);

                set(
                    {
                        tapHistory: newHistory,
                        lastTapTime: now,
                    },
                    false,
                    "recordTap"
                );

                // Need at least MIN_TAPS_FOR_NUDGE taps to calculate tempo
                if (newHistory.length < MIN_TAPS_FOR_NUDGE) {
                    return null;
                }

                // Calculate average interval from tap history
                let totalInterval = 0;
                for (let i = 1; i < newHistory.length; i++) {
                    totalInterval += newHistory[i]! - newHistory[i - 1]!;
                }
                const avgIntervalMs = totalInterval / (newHistory.length - 1);
                const tappedBpm = 60000 / avgIntervalMs;

                // Nudge toward tapped BPM - blend current with tapped
                // Use a weighted blend: 70% current, 30% tapped for gentle nudging
                const nudgeFactor = 0.3;
                const suggestedBpm = currentBpm * (1 - nudgeFactor) + tappedBpm * nudgeFactor;

                return suggestedBpm;
            },

            clearTapHistory: () => {
                set(
                    {
                        tapHistory: [],
                        lastTapTime: null,
                    },
                    false,
                    "clearTapHistory"
                );
            },

            clear: () => set(initialState, false, "clear"),

            // --- Beat Marking Actions ---

            startBeatMarking: () => {
                set(
                    {
                        beatMarkingActive: true,
                        beatMark1: null,
                        beatMark2: null,
                    },
                    false,
                    "startBeatMarking"
                );
            },

            stopBeatMarking: () => {
                set(
                    {
                        beatMarkingActive: false,
                        beatMark1: null,
                        beatMark2: null,
                    },
                    false,
                    "stopBeatMarking"
                );
            },

            placeBeatMark: (timeSec: number) => {
                const { beatMark1, beatMark2 } = get();

                if (!beatMark1) {
                    // Place beat 1
                    set({ beatMark1: { timeSec } }, false, "placeBeatMark1");
                } else if (!beatMark2) {
                    // Place beat 2
                    set({ beatMark2: { timeSec } }, false, "placeBeatMark2");
                } else {
                    // Both marks exist - replace the one further from the click
                    const dist1 = Math.abs(timeSec - beatMark1.timeSec);
                    const dist2 = Math.abs(timeSec - beatMark2.timeSec);
                    if (dist1 < dist2) {
                        set({ beatMark1: { timeSec } }, false, "updateBeatMark1");
                    } else {
                        set({ beatMark2: { timeSec } }, false, "updateBeatMark2");
                    }
                }
            },

            updateBeatMark: (beatIndex: 1 | 2, timeSec: number) => {
                if (beatIndex === 1) {
                    set({ beatMark1: { timeSec } }, false, "updateBeatMark1");
                } else {
                    set({ beatMark2: { timeSec } }, false, "updateBeatMark2");
                }
            },

            resetBeatMarks: () => {
                set(
                    {
                        beatMark1: null,
                        beatMark2: null,
                    },
                    false,
                    "resetBeatMarks"
                );
            },

            getMarkedBpm: () => {
                const { beatMark1, beatMark2 } = get();
                if (!beatMark1 || !beatMark2) return null;

                const interval = Math.abs(beatMark2.timeSec - beatMark1.timeSec);
                if (interval <= 0) return null;

                const bpm = 60 / interval;

                // Check for reasonable BPM range
                if (bpm < 20 || bpm > 400) return null;

                // Phase offset is the earlier beat
                const phaseOffset = Math.min(beatMark1.timeSec, beatMark2.timeSec);

                return { bpm, phaseOffset };
            },
        }),
        { name: "manual-tempo-store" }
    )
);
